# 상속의 문제점

> concrete class가 너무 많아짐
>

스타벅스 커피 전문점의 음료를 나타내는 추상 클래스 : Beverage를 두고
메뉴가 추가될때마다 서브 클래스를 추가하게 되면 클래스가 겉잡을 수 없이 많아진다.

> 컴파일 시점에 행동이 정적으로 정해짐
>

# 디자안 원칙 :OCP

**Open-Closed Principle**

> 클래스의 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

기존 코드를 건드리지 않고 확장이 가능할까? -> observer 패턴

# 데코레이터 패턴

![img.png](../../../../img/decorator/img.png)
![img.png](../../../../img/decorator/img2.png)

> 객체에 추가 요소를 동적으로 더할 수 있는 패턴으로, 서브클래스를 만들 때보다 유연하게 기능읗 확장할 수 있는 특징이 있다.

- 데코레이터의 슈퍼 클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 동일하다
    - 그렇기 때문에, wrapping된 객체가 들어갈 자리에 데코레이터 객체를 넣을 수 있다
- 하나의 객체를 여러 데이코레이터로 감쌀(Wrapping) 수 있다
- **데코레이터는 객체에 행동을 위임하는 일과 함께 추가 작업을 수행할 수 있다** (키 포인트)

## 데코레이터 패턴 예제에서 "상속"이 사용되는 이유

데코레이터의 특징은 "데코레이터로 감싸는 객체"의 형식과 "데코레이터"의 형식이 같다는 것이다.
이 형식을 "상속"으로서 맞추는 것이다. (도구로서 상속이 활용 됨)

- 상속은 행동이 컴파일 시점에 정해져버리지만, 데코레이터 패턴은 구성을 활용하여 실행중에 조합해서 사용할 수 있다.

또한 기존 코드에서 Beverage 라는 추상 클래스를 사용하고 있기 때문에 기존 코드를 고치지 않고 "상속"으로 형식을 맞추었다.

- 상속 대신 "인터페이스"로 형식을 맞출 수 있다.

## 데코레이터 패턴의 예시 : 자바 I/O

![img.png](../../../../img/decorator/img3.png)
